#############################################################################!
# HELPER FUNCTIONS                                                       ####
#############################################################################!

#' Measurement models available in `bmm`
#'
#' @param print_call Logical; If TRUE (default), the function will print information about
#'  how each model function should be called and its required arguments. If FALSE,
#'  the function will return a character vector with the names of the available
#'  models
#' @return A character vector of measurement models available in `bmm`
#' @export
#'
#' @examples
#' supported_models()
supported_models <- function(print_call=TRUE) {
  supported_models <- lsp("bmm", pattern = "^\\.model_")
  supported_models <- sub("^\\.model_", "", supported_models)
  if (print_call) {
    out <- "The following models are supported:\n\n"
    for (model in supported_models) {
      args <- methods::formalArgs(get(model))
      args <- args[!args %in% c("...")]
      args <- collapse_comma(args)
      args <- gsub("'", "", args)
      out <- paste0(out, '- `', model,'(',args,')`', "\n", sep='')
    }
    out <- paste0(out, "\nType ?modelname to get information about a specific model, e.g. ?IMMfull\n")
    cat(gsub("`", " ", out))
    return(invisible(out))
  }
  return(supported_models)
}

#' @title Generate a markdown list of the measurement models available in `bmm`
#' @description Used internally to automatically populate information in the README file
#' @return Markdown code for printing the list of measurement models available in `bmm`
#' @export
#' @keywords internal
print_pretty_models_md <- function() {
  ok_models <- supported_models(print_call=FALSE)
  domains <- c()
  models <- c()
  for (model in ok_models) {
    m <- get_model(model)()
    domains <- c(domains, m$info$domain)
    models <- c(models, m$info$name)
  }
  unique_domains <- unique(domains)
  for (dom in unique_domains) {
    cat('####', dom, '\n\n')
    dom_models <- unique(models[domains == dom])
    for (model in dom_models) {
      cat('*', model, '\n\n')
    }
  }
}

model_info <- function(model, components = 'all') {
  UseMethod("model_info")
}


#' @export
model_info.bmmmodel <- function(model, components = 'all') {
  pars <- model$info$parameters
  par_info <- ""
  if (length(pars) > 0) {
    for (par in names(pars)) {
      par_info <- paste0(par_info, "   - `", par, "`: ", pars[[par]], "\n")
    }
  }

  info_all <-   list(
    domain = paste0("* **Domain:** ", model$info$domain, "\n\n"),
    task = paste0("* **Task:** ", model$info$task, "\n\n"),
    name = paste0("* **Name:** ", model$info$name, "\n\n"),
    citation = paste0("* **Citation:** \n\n   - ", model$info$citation, "\n\n"),
    version = paste0("* **Version:** ", model$info$version, "\n\n"),
    requirements = paste0("* **Requirements:** \n\n  ", model$info$requirements, "\n\n"),
    parameters = paste0("* **Parameters:** \n\n  ", par_info, "\n\n")
  )

  if (length(components) == 1 && components == 'all') {
    components <- names(info_all)
  }

  if (model$info$version == "NA" || model$info$version == "") {
    components <- components[components != "version"]
  }

  # return only the specified components
  return(collapse(info_all[components]))
}

#' Checks if the model is supported, and returns the model function
#' @param model A string with the name of the model supplied by the user
#' @return A list generated by a model function of type .model_*
#' @noRd
check_model <- function(model) {
  model_label <- class(model)[length(class(model))]
  ok_models <- supported_models(print_call=FALSE)
  if (not_in(model_label, ok_models)) {
    stop(model_label, " is not a supported model. Supported ",
         "models are:\n", collapse_comma(ok_models))
  }

  return(model)
}



#' @param model A string with the name of the model supplied by the user
#' @return A function of type .model_*
#' @details the returned object is a function. To get the model object, call the
#'   returned function, e.g. `get_model("mixture2p")()`
#' @noRd
get_model <- function(model) {
  get(paste0('.model_', model), mode='function')
}

get_model2 <- function(model) {
  get(model, mode='function')
}





use_model_template <- function(model_name, testing=FALSE) {
  file_name <- paste0('bmm_model_', model_name, '.R')
  # check if model exists
  if (model_name %in% supported_models(print_call=FALSE)) {
    stop(paste0("Model ", model_name, " already exists"))
  }
  if (file.exists(paste0('R/', file_name))) {
    stop(paste0("File ", file_name, " already exists"))
  }

  model_header <- paste0(
  "#############################################################################!\n",
  "# MODELS                                                                 ####\n",
  "#############################################################################!\n",
  "# Each model should have a corresponding .model_* function which returns a list\n",
  "# with the following attributes:\n",
  "#   domain: the domain of the model (e.g. 'Visual working memory')\n",
  "#   name: the name of the model (e.g. 'Two-parameter mixture model by Zhang and Luck (2008).')\n",
  "#   citation: the citation for the model (e.g. Zhang, W., & Luck, S. J. (2008).\n",
  "#             Discrete fixed-resolution representations in visual working memory.\n",
  "#             Nature, 453(7192), 233-235.) \n",
  "#   class: a character vector with the class of the model (e.g. c('vwm','mixture2p'))\n",
  "#\n",
  "# The class attribute is used by generic S3 functions to perform data checks and\n",
  "# model configuration. The classes should be ordered from most general to most\n",
  "# specific c('vwm','nontargets','mixture3p'). A general class exists when the same operations\n",
  "# can be performed on multiple models. For example, the 'mixture3p', 'IMMabc', 'IMMbsc'\n",
  "# and 'IMMfull' models all have non-targets and setsize arguments, so the same\n",
  "# data checks can be performed on all of them. The 'mixture2p' model does not have\n",
  "# non-targets or setsize arguments, so it has a different class.\n\n\n")

  check_data_header <- paste0(
  "\n\n\n#############################################################################!\n",
  "# CHECK_DATA S3 methods                                                  ####\n",
  "#############################################################################!\n",
  "# A check_data.* function should be defined for each class of the model.\n",
  "# If a model shares methods with other models, the shared methods should be\n",
  "# defined in data-helpers.R. Put here only the methods that are specific to\n",
  "# the model. See ?check_data for details\n\n\n")

  configure_model_header <- paste0(
  "\n\n\n#############################################################################!\n",
  "# CONFIGURE_MODEL S3 METHODS                                             ####\n",
  "#############################################################################!\n",
  "# Each model should have a corresponding configure_model.* function. See\n",
  "# ?configure_model for more information.\n\n\n")

  model_object <- glue::glue(".model_<<model_name>> <- function() {\n",
                             "   out <- list()\n",
                             "   attr(out, 'domain') <- ''\n",
                             "   attr(out, 'name') <- ''\n",
                             "   attr(out, 'citation') <- ''\n",
                             "   class(out) <- c('<<model_name>>')\n",
                             "   out\n",
                             "}\n\n",
                             .open = "<<", .close = ">>")

  check_data_method <- glue::glue("#' @export\n",
                                  "check_data.<<model_name>> <- function(model, data, formula) {\n",
                                  "   dots <- list(...)\n\n",
                                  "   # check if arguments are valid (required)\n\n\n",
                                  "   # compute any necessary transformations (optional)\n\n\n",
                                  "   # save some variables as attributes of the data for later use (optional)\n\n\n",
                                  "   data = NextMethod('check_data')\n\n",
                                  "   return(data)\n",
                                  "}\n\n",
                                  .open = "<<", .close = ">>")

  configure_model_method <- glue::glue("#' @export\n",
                                       "configure_model.<<model_name>> <- function(model, data, formula) {\n",
                                       "   dots <- list(...)\n\n",
                                       "   # retrieve arguments from the data check\n",
                                       "   my_precomputed_var <- attr(data, 'my_precomputed_var')\n\n\n",
                                       "   # construct the formula\n",
                                       "   formula <- formula + brms::lf()\n\n\n",
                                       "   # construct the family\n",
                                       "   family <- NULL\n\n\n",
                                       "   # construct the default prior\n",
                                       "   prior <- NULL\n\n\n",
                                       "   # return the list\n",
                                       "   out <- nlist(formula, data, family, prior)\n",
                                       "   return(out)\n",
                                       "}\n\n",
                                       .open = "<<", .close = ">>")

  file_content <- paste0(model_header,
                             model_object,
                             check_data_header,
                             check_data_method,
                             configure_model_header,
                             configure_model_method)

  if (!testing) {
    writeLines(file_content, paste0('R/', file_name))
  } else {
    return(file_content)
  }
}
