---
title: "BRMS Stan data structure"
author: Ven Popov
format: 
  html:
    embed-resources: true
    toc: true
execute: 
  cache: true
editor: visual
---

```{r setup, include=FALSE}
pacman::p_load(here, tidyverse, devtools, bmm, brms)

nSub <- 4
setsize <- c(3,6,9)
material <- c("color", "orientation")
nTrials <- 5

simParms <- expand.grid(
  subID = 1:nSub,
  setsize = setsize,
  material = material
)

library(tidyverse)
simParms <- simParms %>%
  mutate(
    c = case_when(setsize == 3 ~ rnorm(n(), mean = 3, sd = 0.5),
                  TRUE ~ rnorm(n(), mean = 2, sd = 0.5)),
    kappa = case_when(material == "color" ~ rnorm(n(), mean = 8, sd = 1.5),
                      TRUE ~ rnorm(n(), mean = 6, sd = 1.5))
  )

simData <- data.frame(
  subID = integer(),
  setsize = integer(),
  material = character(),
  dev_rad = numeric()
)

for (i in 1:nrow(simParms)) {
  devRad <- bmm::rsdm(n = nTrials, c = simParms$c[i], kappa = simParms$kappa[i])
  
  subData <- data.frame(
    subID = simParms$subID[i],
    setsize = simParms$setsize[i],
    material = simParms$material[i],
    dev_rad = devRad
  )
  
  simData <- rbind(simData,subData)
}

simData$setsize <- as.factor(simData$setsize)
```

::: callout-note
This document is a work in progress
:::

## Introduction

This is a utility document to explore the stan data structure generated by `brms` for a variety of formulas. The goal is to understand how the data is organized so that I can write a user-friendly function for setting initial values[^1]. Currently it's quite opaque and cumbersome[^2].

[^1]: Implementing such a function was discussed for brms [here](https://github.com/paul-buerkner/brms/issues/883#issuecomment-618948473), but seems like it has not been done yet

[^2]: for example, see how Henrik does it [here](http://singmann.org/wiener-model-analysis-with-brms-part-i/) - it works and I'll use it as a starting point, but ideally I don't want to do this manually for every model and design. Also look into the functions described [here](https://users.aalto.fi/~ave/casestudies/Birthdays/birthdays.html#Workflow_for_quick_iterative_model_building)

To generate initial value, we need to know two things:

-   How key information about the data and predictors is structured (from the stan data)
-   Which parameters are being estimated (from the stan code)

## Example init function

Following the example by Henrik, here's a function that sets initial values for a simple model (in `bmm`, but raw `brms` is similar). First, we need to extract the stan data and the stan code for the parameters block:

```{r}
#| code-fold: true
pacman::p_load(here, tidyverse, brms, bmm)

# setup data and model formula
dat <- bmm::OberauerLin_2017
dat$SetSize <- as.factor(dat$SetSize)
formula <- bf(dev_rad ~ 1,
              c ~ 0 + SetSize + (0 + SetSize || ID),
              kappa ~ 1 + (1 | ID))

# get standata
sdat <- get_standata(formula = formula,
                     data = dat,
                     model = sdmSimple())

# get stan code for parameters block
stan_code <- get_stancode(formula = formula,
                          data = dat,
                          model = sdmSimple())
par_block <- str_match(as.character(stan_code), 
                       "(?s)parameters \\{\\n(.*?)\\}\\ntransformed")[,2]
```

The standata looks like this:

```{r}
str(sdat,  give.attr=F) 
```

And the parameters block looks like this:

```{r}
cat(par_block)
```

We need to define initial values for every parameter listed in the parameters block, and get the appropriate dimensions from the stan data. Here's a function that does this:

```{r}
initfun <- function(seed) {
  set.seed(seed)
  list(
    b_c = as.array(runif(sdat$K_c,0,2)),
    Intercept_kappa = runif(1,0,2),
    sd_1 = as.array(runif(sdat$M_1,0,1)),
    sd_2 = as.array(runif(sdat$M_2,0,1)),
    z_1 = matrix(rnorm(sdat$M_1*sdat$N_1, 0, 0.01),
                 sdat$M_1, sdat$N_1),
    z_2 = matrix(rnorm(sdat$M_2*sdat$N_2, 0, 0.01),
             sdat$M_2, sdat$N_2)
  )
}
```

This function can be used to set initial values for the model:

```{r}
initlist <- list(
  initfun(1),
  initfun(2),
  initfun(3),
  initfun(4)
)
```

and then we would run the model as

``` r
fit_model(formula, dat, sdmSimple(), 
          parallel=T, init=initlist, backend='cmdstanr')
```

But I don't want to code this initfun for every possible design and model.

## Formula generation

Generate a bunch of different formulas:

```{r ff-gen}
#| code-fold: true
dat <- simData
ff <- list()

i=1

ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 1,
                    kappa ~ 1); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ setsize,
                    kappa ~ 1); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 0 + setsize,
                    kappa ~ 1); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 0 + setsize,
                    kappa ~ material); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 0 + setsize*material,
                    kappa ~ material); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 0 + setsize*material,
                    kappa ~ setsize*material); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 1 + (1|subID),
                    kappa ~ 1); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 1,
                    kappa ~ 1 + (1|subID)); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 1 + (1|subID),
                    kappa ~ 1 + (1|subID)); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 1 + (1|p1|subID),
                    kappa ~ 1 + (1|p1|subID)); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 0 + setsize + (1 | subID),
                    kappa ~ material + (1 | subID)); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 0 + setsize + (0 + setsize | subID),
                    kappa ~ material + (material | subID)); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 0 + setsize + (0 + setsize | subID),
                    kappa ~ material*setsize + (material | subID)); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 0 + setsize + (0 + setsize | subID),
                    kappa ~ material*setsize + (material*setsize | subID)); i=i+1
ff[[i]] <- brms::bf(dev_rad ~ 1,
                    c ~ 0 + setsize + (0 + setsize | subID),
                    kappa ~ 0 + material*setsize + (0 + material*setsize | subID)); i=i+1
```

## Stan data

Extract the standata for each formula:

```{r get_standata}
# get standata 
sdat <- list()
for (i in 1:length(ff)) {
  sdat[[i]] <- get_standata(formula = ff[[i]],
                        data = dat,
                        model = sdmSimple())
}

# get stan code
stan_code <- list()
pars_block <- list()
for (i in 1:length(ff)) {
  stan_code[[i]] <- get_stancode(formula = ff[[i]],
                          data = dat,
                          model = sdmSimple())
  pars_block[[i]] <- str_match(as.character(stan_code[[i]]), 
                                   "(?s)parameters \\{\\n(.*?)\\}\\ntransformed")[,2]
}
```

Here's the structure for each formula:

::: panel-tabset
```{r print_standata}
#| results: asis
# print standata structure
for (i in 1:length(sdat)) {
  cat("## Formula ", i, "\n")
  cat("### Data pars\n\n") 
  
  cat(
    "* nSub: 4\n",
    "* setsize: 3 levels (3,6,9)\n",
    '* material: 2 levels ("color", "orientation")\n',
    '* nTrials: 5\n',
    '* Total obs: 120\n\n',
    sep = ""
  )  
  
  cat("### Formula\n\n")
  cat("``` r\n")
  brms:::print.brmsformula(ff[[i]])
  cat("```\n\n")
  
  cat("### Stan code (parameters block)\n\n")
  cat("``` r\n")
  cat(pars_block[[i]])
  cat("\n\n")
  cat("```\n\n")
  
  cat("### Stan data structure\n\n")
  cat("``` r\n")
  str(sdat[[i]],3)
  cat("\n\n")
  cat("```\n\n")

}
```
:::

### Explanation of stan data structure

Always present:

-   `N`: total number of observations
-   `Y`: vector\[N\] of responses
-   `K`, `K_c`, `K_kappa`: number of predictors for each parameter (general form: `K_dpar`)
-   `Kc`, `Kc_c`, `Kc_kappa`: number of centered predictors for each parameter. (general form: `Kc_dpar`)
    -   argument missing if intercept is supressed
    -   `K_dpar`-1 if intercept is included
-   `X`, `X_c`, `X_kappa`: population-level design matrix\[N, K_dpar\] for each parameter (general form: `X_dpar`)
    -   colnames are the names of the predictors as they would appear in the model fit, e.g.:
        -   `r colnames(sdat[[6]]$X_kappa)`
        -   `r colnames(sdat[[6]]$X_c)`

Only present if random effects are included:

-   `Z_1_c_1`,`Z_1_c_2`, ... `Z_1_kappa_1`: random effects predictor values, vector\[N\] for each parameter (general form: `Z_dpar`)
-   `J_1`, `J_2`, ... : vector\[N\] grouping indicator for the random effects (e.g. values of subID)
    -   `J_1` is the grouping indicator for the first random effect that appears in the formula
-   `N_1`, `N_2`,...: number of grouping levels for the random effects (e.g. number of unique subID values)
-   `M_1`, `M_2`...: numer of random effects coefficients (e.g. 1 if only random intercepts are included)
-   `NC_1`, `NC_2`,...: number of group-level correlations

## Component parts of pars/inits

All possible parts for the sdmSimple are:

-   [**if only intercept**]{.underline}
    -   real\[1\] Intercept_c
    -   real\[1\] Intercept_kappa
-   [**if predictors but intercept is not supressed**]{.underline}
    -   real\[1\] Intercept_c
    -   real\[1\] Intercept_kappa
    -   vector\[Kc_c\] b_c
    -   vector\[Kc_kappa\] b_kappa
-   [**If predictors but intercept is supressed**]{.underline}
    -   vector\[K_c\] b_c
    -   vector\[K_kappa\] b_kappa
-   [**If random effects are included**]{.underline}
    -   \[M_1\] sd_1
    -   \[M_2\] sd_2
    -   matrix\[M_1, N_1\] z_1
    -   matrix\[M_2, N_2\] z_2

## Steps for constructing an init function automatically

1.  Get the names of all distributional parameters
2.  Get priors on the parameters
3.  Exclude any parameters that have constant priors
4.  For every distributional parameter, determine if they have an intercept or not
5.  Get the names of variables in the list of stan data
6.  Check the stan data for the presence of
    1.  Intercept\_\*
    2.  Kc\_\*
    3.  K\_\*
    4.  M\_#
    5.  N\_#

alternatively maybe write a script to parse the stan code parameters block?

## How to extract the parameters

I can extract the parameter names from the formula

```{r}
# TODO: Need to export the family so that it is accessible for these functions
f <- brms::bf(dev_rad ~ 1,
              c ~ 0 + setsize + (0 + setsize | subID),
              kappa ~ material*setsize + (material*setsize | subID))
family <- configure_model(sdmSimple(),dat,f)$family
f <- brms::bf(f, family=family)

bterms <- brms::brmsterms(f)
dpars <- names(bterms$dpars)[-1]
ranef <- brms:::tidy_ranef(bterms, data=dat)

data <- brms:::validate_data(dat, bterms = bterms)
```

<!-- everything about the `c` parameter for example should be able to get from here: -->

```{r, include=FALSE, eval=FALSE}
c_terms <- bterms$dpars[['c']]
kappa_terms <- bterms$dpars[['kappa']]

has_intercept <- function (formula) 
{
    if (is.terms(formula)) {
        out <- as.logical(attr(formula, "intercept"))
    }
    else {
        formula <- as.formula(formula)
        try_terms <- try(terms(formula), silent = TRUE)
        if (is_try_error(try_terms)) {
            out <- FALSE
        }
        else {
            out <- as.logical(attr(try_terms, "intercept"))
        }
    }
    out
}

```

```{r, include=FALSE, eval=FALSE}
#brms:::stan_fe



bterms <- kappa_terms


fixef <- colnames(brms:::data_fe(bterms, data)$X)
center_X <- brms:::stan_center_X(bterms)
ct <- brms:::str_if(center_X, "c")
if (center_X) {
  fixef <- setdiff(fixef, "Intercept")
}
px <- brms:::check_prefix(bterms)
p <- brms:::usc(brms:::combine_prefix(px))
if (length(fixef)) {
  b_type <- glue::glue("vector[K{ct}{p}]")
}


cat(brms:::stan_fe(kappa_terms,data=dat, normalize=T, prior=get_model_prior(f, dat, sdmSimple()), primitive=T)$par)
```
