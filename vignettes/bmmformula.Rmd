---
title: "Introduction to `bmmformula` syntax"
output: bookdown::html_document2
author: 
  - Ven Popov
  - Gidon Frischkorn
bibliography: REFERENCES.bib
header-includes:
  - \usepackage{amsmath}
vignette: >
  %\VignetteIndexEntry{Intorduction: bmmformula}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
pkgdown:
  as_is: true
---
<style type="text/css">
div.main-container {
max-width: 800px !important;
}

p {
margin-top: 1.5em ;
margin-bottom: 1.5em ;
}
.author{
    display: none;
}
</style>

```{r, include = FALSE}
options(crayon.enabled = TRUE)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "jpeg",
  dpi = 100
)
fansi::set_knit_hooks(knitr::knit_hooks, which = c("output","message","error"))
```

# The `bmmformula` syntax

The `bmmformula` syntax generally follows the same principles as the formula syntax for [`brms` models](https://rdrr.io/cran/brms/man/brmsformula.html). A `bmmformula` follows the general structure:

```r
parameter ~ fixed + (random | group)
```

Instead of predicting a `response` - as is typically done in `brms` - we predict a `parameter` from a `bmmmodel`[^1]. The `fixed` part specifies all effects that are assumed to be the same across observations. In typical vocabulary such effects are called 'fixed', 'population-level' or 'overall' effects. The `random` part specifies effects that are assumed to vary across grouping variables specified in `group`. Typically, these effects are called 'random', 'group-level' or 'varying' effects.

[^1]: You can always find information on the parameters of a `bmmmodel` by calling the help for the model you want to fit: `?bmmmodel`

As the response is not explicit from the `bmmformula`, we have to specify which response variables the model should be fit to when setting up the `bmmmodel` that should be fit to the data. For example, when fitting the `mixture3p` model, we have to provide the names of the variables that reflect the response error and the location of the non-target features in our data:

```r
myModel <- mixture3p(resp_err = "y", nt_features = "nt_loc", regex = T)
```

Internally, `bmm` will then link the response variables to the formula given for the parameters of a `bmmmodel`.

As you will typically, provide a formula for each parameter of a `bmmmodel` we recommend to set up the formula in a seperate object before passing it to the `fit_model` function. There are two ways to set up formulas that work equally well:

1. a single call to the function `bmmformula` or its short form `bmf` and separate formulas for different parameters by comma. 
2. add formulas to an existing object by using the `+` operator. 

Î—ere are two examples that would result in the same `bmmformula` object:

```r
myFormula <- bmmformula(
  thetat ~ 1 + set_size,
  thetant ~ 1 + set_size,
  kappa ~ 1
)

myFormula <- bmf(thetat ~ 1 + set_size) +
  bmf(thetant ~ 1 + set_size) +
  bmf(kappa ~ 1)
```

# Fixing parameters

# Accessing the `brmsformula` generated by `bmm`

```{r, include=FALSE, warning=FALSE, message=FALSE}
bmmfit <- bmm:::bmmfit_mixture2p_vignette
```

Users that are interested to see how the `bmmformula` that they passed to `bmm` is converted to a `brmsformula` can access the `brmsformula` via the `bmmfit` object that will be returned by the `fit_model` function. Accessing the `formula` object stored in the fit object via `bmmfit$formula` will print out the `brmsformula` generated by `bmm` for the specified model.

For example, if we had specified the following `user_formula` for the `mixture2p` model:

```r
user_formula <- bmmformula(
   kappa ~ 0 + set_size + (0 + set_size || id),
  thetat ~ 0 + set_size + (0 + set_size || id)
)
```

We can access the `brmsformula` generated for this model by calling `bmmfit$formula`:

```{r}
bmmfit$formula
```

Similarly, users can access the distributional family that was used to implement the specified `bmmmodel`, so `bmmfit$family` will return the family object that was generated by `bmm` and then passed to `brms` for fitting. 

```{r}
bmmfit$family
```

Finally, users can also access the data that was used by `bmm` to fit the model via `bmmfit$data`. In many cases this data will be equal to the data provided by the user. But sometimes `bmm` internally computes additional index variables for specifying the models adequately. The data stored in the `bmmfit` object contains these additional variables.

```{r}
head(bmmfit$data)
```

This way users who are interested to customize `bmmmodels` to fit them in `brms` without `bmm` are able to obtain the most important information that is essential for specifying the models implemented in `bmm`. Likewise users can call a `brms` summary instead of a `bmm` summary by setting the `backend` option in the summary function to `brms`. This way the summary function for `brmsfit` objects will be used instead of the function for `bmmfit` objects. The `brmsfit` summary also contains the `brmsformula` that is created by `bmm`.


